# Modification of the module is allowed only if the license is retained.
# MMP""MM""YMM `7MMF'   `7MF' `7MM"""Mq.  7MM"""YMM
# P'   MM   `7   `MA     ,V     MM   `MM.  MM    7
#     MM         VM:   ,V      MM   ,M9   MM   d
#     MM          MM.  M'      MMmmd_M9    MMmmMM
#     MM          `MM A'       MM         MM   Y  ,
#     MM           :MM;        MM         MM     ,M
#   .JMML.          VF       .JMML.     .JMMmmmmMMM
#                  ,M
# This module is licensed and fully copyrighted by Type, copyright is allowed while maintaining the author's mention in the code.
# meta developer: @TypeModules

# requires: pylast yandex-music aiohttp

import asyncio
import re
import json
import random
import string
import time
import logging

import aiohttp
import pylast
import yandex_music
from yandex_music.exceptions import UnauthorizedError, NotFoundError
from telethon.errors.rpcerrorlist import MessageNotModifiedError, MessageIdInvalidError, FloodWaitError

from .. import loader, utils

logger = logging.getLogger(__name__)

@loader.tds
class Lfm(loader.Module):
    """–ì–∏–±—Ä–∏–¥–Ω—ã–π –º–æ–¥—É–ª—å —Å—Ç–∞—Ç—É—Å–∞ –º—É–∑—ã–∫–∏ —Å –ø—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω—ã–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –∂–∏–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–∞."""

    strings = {
        "name": "HybridMusic",
        "now_playing": '<emoji document_id=5258500422393415126>üé§</emoji><b>–°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç:</b> <i>{artist} - {title}</i> <b>|</b> <a href="https://music.yandex.ru/track/{id}">–Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞</a>',
        "now_playing_lfm": '<emoji document_id=5258500422393415126>üé§</emoji><b>–°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç:</b> <i>{artist} - {title}</i> <b>|</b> Last.fm',
        "playlist_info": '<emoji document_id=5301219129192115723>‚ù§Ô∏è</emoji> <b>–ü–ª–µ–π–ª–∏—Å—Ç:</b> <i>{context}</i>',
        "lyrics_block": '<emoji document_id=5258217809250372293>üé•</emoji><b>–¢–µ–∫—Å—Ç:</b>\n<blockquote><b>{current}</b>\n<i>{next}</i></blockquote>',
        "no_lyrics_block": '<emoji document_id=5258217809250372293>üé•</emoji><b>–¢–µ–∫—Å—Ç:</b> üòî <i>–¢–µ–∫—Å—Ç –¥–ª—è —ç—Ç–æ–≥–æ —Ç—Ä–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.</i>',
        "recent_tracks_block": '<emoji document_id=5258387666616994756>‚ùì</emoji> <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ {count} —Ç—Ä–µ–∫–æ–≤:</b>\n<blockquote expandable>{tracks}</blockquote>',
        
        "no_playing": '<emoji document_id=5409230238062247909>üîù</emoji> <b>–ù–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç</b>',
        "paused": '<emoji document_id=5411192398166396991>üí£</emoji> <b>–¢—Ä–µ–∫ –Ω–∞ –ø–∞—É–∑–µ</b>',
        "loading": "<i>–ó–∞–ø—É—Å–∫–∞—é –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å...</i>",
        "stopped": "<emoji document_id=5350342542762209455>üòÄ</emoji> <b>–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ</b>",
        "not_running": "<emoji document_id=5350342542762209455>üòÄ</emoji> <b>–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ —ç—Ç–æ–º —á–∞—Ç–µ –∏ —Ç–∞–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω–æ</b>",

        "help_text": """<b>–ì–∞–π–¥ –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –º–æ–¥—É–ª—è HybridMusic</b>

<b>1. –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞ (–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)</b>
–î–ª—è —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è –Ω—É–∂–µ–Ω —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞.
    ‚Ä¢ <b>–ì–¥–µ –≤–∑—è—Ç—å:</b> –ï—Å—Ç—å <a href="https://github.com/MarshalX/yandex-music-api/discussions/513#discussioncomment-2729781">–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –ü–ö</a> –∏ <a href="https://github.com/MarshalX/yandex-music-api/discussions/513#discussion-3903521">–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã</a>.
    <b>–ö—Ä–∞—Ç–∫–æ –¥–ª—è –ü–ö:</b>
    1. –û—Ç–∫—Ä–æ–π—Ç–µ —Å–∞–π—Ç <a href="https://music.yandex.ru/">music.yandex.ru</a> –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
    2. –ù–∞–∂–º–∏—Ç–µ F12, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤–æ –≤–∫–ª–∞–¥–∫—É "–°–µ—Ç—å" (Network).
    3. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É (F5).
    4. –í —Ñ–∏–ª—å—Ç—Ä–µ –Ω–∞–π–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å –∫ <code>api.music.yandex.net</code>.
    5. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω–µ–≥–æ, —Å–ø—Ä–∞–≤–∞ –æ—Ç–∫—Ä–æ–µ—Ç—Å—è –æ–∫–Ω–æ. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ "–ó–∞–≥–æ–ª–æ–≤–∫–∏" (Headers).
    6. –ü—Ä–æ–ª–∏—Å—Ç–∞–π—Ç–µ –¥–æ "–ó–∞–≥–æ–ª–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞" (Request Headers) –∏ –Ω–∞–π–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É <code>Authorization</code>.
    7. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–æ–∫–µ–Ω –∏–∑ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ (–¥–ª–∏–Ω–Ω—ã–π –Ω–∞–±–æ—Ä —Å–∏–º–≤–æ–ª–æ–≤ <b>–ø–æ—Å–ª–µ</b> —Å–ª–æ–≤–∞ <code>OAuth</code>).
    ‚Ä¢ <b>–ö–∞–∫ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å:</b> <code>fcfg HybridMusic yandex_token –í–ê–®_–¢–û–ö–ï–ù</code>

<b>2. <a href="https://last.fm/">Last.fm</a> (–î–ª—è –∏—Å—Ç–æ—Ä–∏–∏ –∏ —Å–∫—Ä–æ–±–±–ª–∏–Ω–≥–∞ —Å —Ç–µ–ª–µ—Ñ–æ–Ω–∞)</b>
–ù—É–∂–µ–Ω –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–µ–∫–æ–≤ –∏ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –º–æ–¥—É–ª—å –≤–∏–¥–µ–ª –º—É–∑—ã–∫—É, –∫–æ—Ç–æ—Ä—É—é –≤—ã —Å–ª—É—à–∞–µ—Ç–µ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ.
    ‚Ä¢ <b>–®–∞–≥ 1:</b> –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ <a href="https://www.last.fm/join">—Å–∞–π—Ç–µ Last.fm</a>.
    ‚Ä¢ <b>–®–∞–≥ 2:</b> –°–æ–∑–¥–∞–π—Ç–µ API-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ <a href="https://www.last.fm/api/account/create">–∑–¥–µ—Å—å</a>. –ù–∞–∑–≤–∞–Ω–∏–µ –ª—é–±–æ–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "My Userbot").
    ‚Ä¢ <b>–®–∞–≥ 3:</b> –ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ <b>API Key</b> –∏ <b>Shared Secret</b>.
    ‚Ä¢ <b>–ö–∞–∫ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å:</b>
        <code>fcfg HybridMusic api_key –í–ê–®_API_KEY</code>
        <code>fcfg HybridMusic api_secret –í–ê–®_SHARED_SECRET</code>
        <code>fcfg HybridMusic username –í–ê–®_–ù–ò–ö–ù–ï–ô–ú_–ù–ê_LASTFM</code>

<b>3. Pano Scrobbler (–î–ª—è —Å–∫—Ä–æ–±–±–ª–∏–Ω–≥–∞ —Å —Ç–µ–ª–µ—Ñ–æ–Ω–∞)</b>
–≠—Ç–æ Android-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —Ç—Ä–µ–∫–∏ –∏–∑ –ª—é–±–æ–≥–æ –ø–ª–µ–µ—Ä–∞ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏—Ö –Ω–∞ <a href="https://last.fm/">Last.fm</a>.
    ‚Ä¢ <b>–®–∞–≥ 1:</b> –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Pano Scrobbler –∏–∑ Google Play –∏ –∑–∞–ª–æ–≥–∏–Ω—å—Ç–µ—Å—å –≤ –Ω—ë–º —á–µ—Ä–µ–∑ —Å–≤–æ–π <a href="https://last.fm/">Last.fm</a> –∞–∫–∫–∞—É–Ω—Ç.
    ‚Ä¢ <b>–®–∞–≥ 2:</b> <b>–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ</b> –æ—Ç–∫–ª—é—á–∏—Ç–µ –¥–ª—è –Ω–µ–≥–æ —ç–∫–æ–Ω–æ–º–∏—é –∑–∞—Ä—è–¥–∞ –±–∞—Ç–∞—Ä–µ–∏. –ò–Ω–∞—á–µ —Ç–µ–ª–µ—Ñ–æ–Ω –±—É–¥–µ—Ç –µ–≥–æ "—É–±–∏–≤–∞—Ç—å". –ù–∞–π–¥–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–ª—è –≤–∞—à–µ–π –º–∞—Ä–∫–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞ —Å–∞–π—Ç–µ <a href="https://dontkillmyapp.com/">Don't kill my app!</a>.

<b>4. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</b>
–í—ã –º–æ–∂–µ—Ç–µ –≤–∫–ª—é—á–∞—Ç—å/–æ—Ç–∫–ª—é—á–∞–ª—è—Ç—å –±–ª–æ–∫–∏ —á–µ—Ä–µ–∑ <code>fcfg</code>:
    ‚Ä¢ <code>show_lyrics</code>: –ü–æ–∫–∞–∑ –±–ª–æ–∫–∞ —Å —Ç–µ–∫—Å—Ç–æ–º (True/False). <b>–û—Ç–∫–ª—é—á–∏—Ç–µ, –µ—Å–ª–∏ –ª–æ–≤–∏—Ç–µ FloodWait</b>.
    ‚Ä¢ <code>show_recent_tracks</code>: –ü–æ–∫–∞–∑ –±–ª–æ–∫–∞ —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ —Ç—Ä–µ–∫–∞–º–∏ (True/False).
    ‚Ä¢ <code>recent_tracks_count</code>: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–µ–∫–æ–≤ –≤ –∏—Å—Ç–æ—Ä–∏–∏ (–æ—Ç 1 –¥–æ 10).

<b>–í—ã–∂–∏–º–∫–∞ "–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç":</b>
–ú–æ–¥—É–ª—å –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ <b>YaLyricsLive</b> –æ—Ç <i>@dev_angel_7553</i>.
1. –ö–æ–º–∞–Ω–¥–∞ <code>.lfm</code> –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∞—Ç–∞.
2. –ú–æ–¥—É–ª—å –∫–∞–∂–¥—ã–µ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ —É —Ç–µ–±—è –∏–≥—Ä–∞–µ—Ç –≤ –Ø.–ú—É–∑—ã–∫–µ, <b>–∏–ª–∏</b> —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ <a href="https://last.fm/">Last.fm</a> —Å —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (—á–µ—Ä–µ–∑ Pano Scrobbler). <a href="https://last.fm/">Last.fm</a> –Ω—É–∂–µ–Ω, —á—Ç–æ–±—ã –ª—é–¥–∏ –º–æ–≥–ª–∏ —Å–ª—É—à–∞—Ç—å —Ç—Ä–µ–∫–∏ –≤–µ–∑–¥–µ, –∞ –º–æ–¥—É–ª—å —ç—Ç–æ –≤–∏–¥–µ–ª.
3. –ï—Å–ª–∏ —Ç—Ä–µ–∫ –∏–≥—Ä–∞–µ—Ç, –æ–Ω —Ö–≤–∞—Ç–∞–µ—Ç –≤—Å—é –∏–Ω—Ñ—É: –Ω–∞–∑–≤–∞–Ω–∏–µ, –ø–ª–µ–π–ª–∏—Å—Ç, —Ç–µ–∫—Å—Ç —Å —Ç–∞–π–º–∫–æ–¥–∞–º–∏.
4. –î–∞–ª—å—à–µ –æ–Ω –ø–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É —Ç–∞–π–º–µ—Ä—É –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç—Ä–æ–∫–∏ —Ç–µ–∫—Å—Ç–∞, —á—Ç–æ–±—ã –Ω–µ –¥–æ–ª–±–∏—Ç—å API –Ø–Ω–¥–µ–∫—Å–∞.
5. –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –æ–Ω –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —É <a href="https://last.fm/">Last.fm</a> —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç—Ä–µ–∫–æ–≤ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏.
6. –í—Å—è –∏–Ω—Ñ–∞ —Å–æ–±–∏—Ä–∞–µ—Ç—Å—è –≤ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø–æ –º–µ—Ä–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.
7. –ú–æ–¥—É–ª—å —É–º–µ–µ—Ç —Å–∞–º –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—Ç—å—Å—è –∫ API, –µ—Å–ª–∏ —Å–µ—Å—Å–∏—è "–ø—Ä–æ—Ç—É—Ö–ª–∞", –∏ –∞–¥–∞–ø—Ç–∏—Ä—É–µ—Ç—Å—è –∫ –ª–∏–º–∏—Ç–∞–º –¢–µ–ª–µ–≥—Ä–∞–º–∞.
""",
    }

    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue("yandex_token", None, "OAuth-—Ç–æ–∫–µ–Ω –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∏"),
            loader.ConfigValue("api_key", None, "API Key –æ—Ç Last.fm"),
            loader.ConfigValue("api_secret", None, "API Secret –æ—Ç Last.fm", validator=loader.validators.Hidden()),
            loader.ConfigValue("username", None, "–ù–∏–∫–Ω–µ–π–º –Ω–∞ Last.fm"),
            loader.ConfigValue("update_interval", 15, "–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–ø—Ä–æ—Å–∞ –≤ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ (—Å–µ–∫)", validator=loader.validators.Integer(minimum=5)),
            loader.ConfigValue("force_resync", False, "–í–∫–ª—é—á–∏—Ç—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—É—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –∂–∏–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–∞?", validator=loader.validators.Boolean()),
            loader.ConfigValue("resync_interval_sec", 30.0, "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (—Å–µ–∫)", validator=loader.validators.Float(minimum=0.001, maximum=999999.0)),
            loader.ConfigValue("show_lyrics", True, "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–ª–æ–∫ —Å —Ç–µ–∫—Å—Ç–æ–º? (–ú–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å FloodWait)", validator=loader.validators.Boolean()),
            loader.ConfigValue("show_recent_tracks", True, "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–µ–∫–∏ –∏–∑ Last.fm?", validator=loader.validators.Boolean()),
            loader.ConfigValue("recent_tracks_count", 5, "–°–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç—Ä–µ–∫–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å (1-10)", validator=loader.validators.Integer(minimum=1, maximum=10)),
        )
        self.ym_client = None
        self.lfm_network = None
        self.bg_tasks = {}
        self.last_texts = {}

    async def on_unload(self):
        for task in self.bg_tasks.values():
            task.cancel()

    async def client_ready(self, client, db):
        await self._init_clients()

    async def _init_clients(self):
        """(Re)Initializes API clients."""
        if self.config["yandex_token"]:
            try:
                self.ym_client = await yandex_music.ClientAsync(self.config["yandex_token"]).init()
            except UnauthorizedError:
                logger.error("Yandex Music token is invalid!")
                self.ym_client = None
        
        if all((self.config["api_key"], self.config["api_secret"], self.config["username"])):
            try:
                self.lfm_network = pylast.LastFMNetwork(api_key=self.config["api_key"], api_secret=self.config["api_secret"])
            except Exception as e:
                logger.error(f"Failed to initialize Last.fm client: {e}")
                self.lfm_network = None

    async def _update_message(self, message, text):
        try:
            chat_id = utils.get_chat_id(message)
            if self.last_texts.get(chat_id) == text:
                return
            
            await utils.answer(message, text, link_preview=False)
            self.last_texts[chat_id] = text
        except FloodWaitError as e:
            logger.warning(f"Flood wait for {e.seconds} seconds. Sleeping and retrying...")
            await asyncio.sleep(e.seconds)
            await self._update_message(message, text) # Automatic retry
        except (MessageNotModifiedError, MessageIdInvalidError):
            pass
        except Exception as e:
            logger.warning(f"Failed to update message: {e}")

    @loader.command(aliases=["np", "music"], ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å")
    async def lfmcmd(self, message):
        chat_id = utils.get_chat_id(message)
        if chat_id in self.bg_tasks:
            self.bg_tasks[chat_id].cancel()

        msg = await utils.answer(message, self.strings("loading"))
        self.last_texts[chat_id] = ""
        
        task = asyncio.create_task(self._master_loop(msg))
        self.bg_tasks[chat_id] = task

    @loader.command(aliases=["npstop", "musicstop"], ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å")
    async def lfmstopcmd(self, message):
        chat_id = utils.get_chat_id(message)
        if chat_id in self.bg_tasks:
            self.bg_tasks[chat_id].cancel()
            del self.bg_tasks[chat_id]
            await utils.answer(message, self.strings("stopped"))
        else:
            await utils.answer(message, self.strings("not_running"))
            
    @loader.command(ru_doc="–ü–æ–º–æ—â—å –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –º–æ–¥—É–ª—è")
    async def lfmhelp(self, message):
        await utils.answer(message, self.strings("help_text"))

    async def _get_yandex_state(self):
        if not self.ym_client: return "INACTIVE", None, None
        
        for attempt in range(2):
            try:
                ynison = await self._get_ynison(self.config["yandex_token"])
                player_state = ynison.get("player_state", {})
                queue = player_state.get("player_queue", {})
                if not queue or not queue.get("playable_list"): return "INACTIVE", None, None
                idx = queue.get("current_playable_index", -1)
                if not (0 <= idx < len(queue["playable_list"])): return "INACTIVE", None, None
                
                track_id = queue["playable_list"][idx]["playable_id"]
                track_obj = (await self.ym_client.tracks(track_id))[0]
                track_info = {
                    "id": track_id, 
                    "artist": utils.escape_html(", ".join(track_obj.artists_name())), 
                    "title": utils.escape_html(track_obj.title),
                    "duration_ms": track_obj.duration_ms
                }
                
                status = player_state.get("status", {})
                if status.get("paused"): return "PAUSED", track_info, queue

                track_info["progress_ms"] = int(status.get("progress_ms", 0))
                return "PLAYING", track_info, queue
            except Exception as e:
                logger.warning(f"Failed to get Yandex state (attempt {attempt+1}): {e}")
                if attempt == 0:
                    await self._init_clients()
                continue
        
        return "INACTIVE", None, None

    async def _get_lastfm_track(self):
        if not self.lfm_network: return None
        try:
            user = self.lfm_network.get_user(self.config["username"])
            current_track = await asyncio.to_thread(user.get_now_playing)
            if current_track:
                return {"artist": utils.escape_html(current_track.artist.name), "title": utils.escape_html(current_track.title)}
            return None
        except Exception: return None

    async def _master_loop(self, message):
        chat_id = utils.get_chat_id(message)
        last_track_id = None
        last_track_progress_ms = -1
        
        try:
            while True:
                try:
                    ym_status, ym_track, ym_queue = await self._get_yandex_state()
                    
                    if ym_status == "PLAYING":
                        current_track_id = ym_track['id']
                        current_progress_ms = ym_track.get('progress_ms', -1)
                        
                        is_new_or_restarted = (
                            current_track_id != last_track_id or
                            (current_track_id == last_track_id and current_progress_ms < 5000 and last_track_progress_ms > 5000)
                        )

                        if is_new_or_restarted:
                            last_track_id = current_track_id
                            last_track_progress_ms = current_progress_ms
                            await self._handle_yandex_predictive_live(message, ym_track, ym_queue)
                            continue
                        
                        last_track_progress_ms = current_progress_ms
                        await asyncio.sleep(2)
                        continue

                    # --- Yandex is not playing, check Last.fm fallback ---
                    lfm_track = await self._get_lastfm_track()
                    if lfm_track:
                        is_ghost = (ym_status == "PAUSED" and ym_track and
                                    lfm_track["artist"] == ym_track["artist"] and 
                                    lfm_track["title"] == ym_track["title"])
                        if not is_ghost:
                            await self._handle_lastfm_track(message, lfm_track)
                            await asyncio.sleep(self.config["update_interval"])
                            continue
                    
                    # --- If no fallback, show Yandex status ---
                    last_track_id = None
                    last_track_progress_ms = -1
                    
                    recent_tracks_block = await self._get_recent_lfm_tracks(None)
                    text_parts = []
                    if ym_status == "PAUSED":
                        text_parts.append(self.strings("now_playing").format(**ym_track))
                        text_parts.append(self.strings("paused"))
                    else:
                        text_parts.append(self.strings("no_playing"))
                    
                    if recent_tracks_block:
                        text_parts.append(recent_tracks_block)
                        
                    await self._update_message(message, "\n".join(text_parts))
                    
                    await asyncio.sleep(self.config["update_interval"])
                except Exception as e:
                    logger.error(f"Error in master loop: {e}", exc_info=True)
                    await asyncio.sleep(self.config["update_interval"])

        except asyncio.CancelledError:
            pass
        finally:
            self.bg_tasks.pop(chat_id, None)

    async def _get_recent_lfm_tracks(self, exclude_track_info=None):
        if not self.lfm_network or not self.config["show_recent_tracks"]: return ""
        try:
            user = self.lfm_network.get_user(self.config["username"])
            recent_tracks = await asyncio.to_thread(user.get_recent_tracks, limit=self.config["recent_tracks_count"] + 1)
            
            if exclude_track_info:
                # Compare case-insensitively
                exclude_artist = exclude_track_info["artist"].lower()
                exclude_title = exclude_track_info["title"].lower()
                recent_tracks = [
                    t for t in recent_tracks 
                    if not (t.track.artist.name.lower() == exclude_artist and t.track.title.lower() == exclude_title)
                ]

            track_list = [f"{i+1}. {utils.escape_html(t.track.artist.name)} - {utils.escape_html(t.track.title)}" for i, t in enumerate(recent_tracks[:self.config["recent_tracks_count"]])]
            if not track_list: return ""

            return self.strings("recent_tracks_block").format(
                count=len(track_list),
                tracks="\n".join(track_list)
            )
        except Exception as e:
            logger.warning(f"Failed to get recent Last.fm tracks: {e}")
            return ""

    async def _get_yandex_context(self, queue):
        if not queue or not self.ym_client: return "–ü–æ–¥–±–æ—Ä–∫–∞ –¥–ª—è –≤–∞—Å"
        try:
            context = queue.get("entity_context")
            if context == "my_wave_by_default": return "–ú–æ—è –í–æ–ª–Ω–∞"
            
            entity_type = queue.get("entity_type")
            entity_id = queue.get("entity_id")
            if not entity_type or not entity_id: return "–ü–æ–¥–±–æ—Ä–∫–∞ –¥–ª—è –≤–∞—Å"

            if entity_type == "playlist":
                uid, kind = entity_id.split(":")
                playlist = await self.ym_client.users_playlists(kind, uid)
                return playlist.title
            elif entity_type == "album":
                album = await self.ym_client.albums([entity_id])
                return album[0].title
        except Exception as e:
            logger.warning(f"Failed to get yandex context: {e}")
        return "–ü–æ–¥–±–æ—Ä–∫–∞ –¥–ª—è –≤–∞—Å"

    async def _handle_lastfm_track(self, message, track_info):
        """Handler for tracks coming from Last.fm fallback."""
        text_parts = []
        
        # Try to find the track on Yandex Music to get a link
        if self.ym_client:
            try:
                search = await self.ym_client.search(f"{track_info['artist']} {track_info['title']}", type_="track")
                if search.tracks and search.tracks.results:
                    track_id = search.tracks.results[0].id
                    text_parts.append(self.strings("now_playing").format(id=track_id, **track_info))
                else:
                    raise ValueError("Track not found on Yandex Music")
            except Exception:
                text_parts.append(self.strings("now_playing_lfm").format(**track_info))
        else:
            text_parts.append(self.strings("now_playing_lfm").format(**track_info))
        
        if self.config["show_lyrics"]:
            text_parts.append(self.strings("no_lyrics_block")) # No live lyrics from LFM
        
        recent_tracks_block = await self._get_recent_lfm_tracks(track_info)
        if recent_tracks_block:
            text_parts.append(recent_tracks_block)
            
        await self._update_message(message, "\n".join(text_parts))

    async def _handle_yandex_predictive_live(self, message, track_info, queue):
        context_info = await self._get_yandex_context(queue)
        recent_tracks_block = await self._get_recent_lfm_tracks(track_info)
        playlist_info_block = self.strings("playlist_info").format(context=utils.escape_html(context_info))
        playing_now_block = self.strings("now_playing").format(**track_info)
        
        text_parts = [playing_now_block, playlist_info_block]

        if not self.config["show_lyrics"]:
            if recent_tracks_block:
                text_parts.append(recent_tracks_block)
            await self._update_message(message, "\n".join(text_parts))
            
            remaining_ms = track_info.get('duration_ms', 300000) - track_info.get('progress_ms', 0)
            await asyncio.sleep(max(1, remaining_ms / 1000))
            return

        try:
            lyrics_obj = await self.ym_client.tracks_lyrics(track_info["id"], "LRC")
            if not lyrics_obj.download_url: raise NotFoundError
            async with aiohttp.ClientSession() as s, s.get(lyrics_obj.download_url) as r:
                lrc_text = await r.text()
            
            lines = [
                {"ts": (int(m[0]) * 60 + float(m[1])) * 1000, "txt": m[2].strip()}
                for m in re.findall(r"\[(\d+):(\d+\.\d+)\](.*)", lrc_text) if m[2].strip()
            ]
            
            if not lines: raise ValueError("Empty LRC lines")

        except (NotFoundError, ValueError, Exception):
            lyrics_block = self.strings("no_lyrics_block")
            text_parts.append(lyrics_block)
            if recent_tracks_block: text_parts.append(recent_tracks_block)
            await self._update_message(message, "\n".join(text_parts))
            
            remaining_ms = track_info.get('duration_ms', 300000) - track_info.get('progress_ms', 0)
            await asyncio.sleep(max(1, remaining_ms / 1000))
            return
        
        song_duration_ms = lines[-1]['ts']
        initial_progress_ms = track_info.get('progress_ms', 0)
        start_time = time.time()
        last_resync_time = start_time
        current_line_index = -1

        while True:
            now = time.time()
            if self.config["force_resync"] and (now - last_resync_time) > self.config["resync_interval_sec"]:
                status, new_track_info, _ = await self._get_yandex_state()
                if status != "PLAYING" or not new_track_info or new_track_info['id'] != track_info["id"]:
                    return 
                track_info = new_track_info
                initial_progress_ms = track_info.get('progress_ms', 0)
                start_time = now
                last_resync_time = now

            elapsed_time_ms = (now - start_time) * 1000
            progress_ms = initial_progress_ms + elapsed_time_ms

            if progress_ms > song_duration_ms + 2000: return

            new_line_index = next((i for i, line in reversed(list(enumerate(lines))) if line['ts'] <= progress_ms), -1)
            
            if new_line_index != current_line_index:
                current_line_index = new_line_index
                current = lines[current_line_index]['txt']
                next_line = lines[current_line_index + 1]['txt'] if current_line_index + 1 < len(lines) else "..."
                
                lyrics_block = self.strings("lyrics_block").format(current=utils.escape_html(current), next=utils.escape_html(next_line))
                
                final_text_parts = [playing_now_block, playlist_info_block, lyrics_block]
                if recent_tracks_block: final_text_parts.append(recent_tracks_block)
                
                await self._update_message(message, "\n".join(final_text_parts))

            if current_line_index + 1 < len(lines):
                delay = (lines[current_line_index + 1]['ts'] - progress_ms) / 1000.0
                await asyncio.sleep(max(0.01, delay))
            else:
                remaining_time = (song_duration_ms - progress_ms) / 1000.0
                await asyncio.sleep(max(0, remaining_time) + 0.5)
                return

    async def _get_ynison(self, token):
        device_id = "".join(random.choices(string.ascii_lowercase + string.digits, k=32))
        ws_proto = {"Ynison-Device-Id": device_id, "Ynison-Device-Info": json.dumps({"app_name": "Chrome", "type": 1})}
        headers = {"Sec-WebSocket-Protocol": f"Bearer, v2, {json.dumps(ws_proto)}", "Origin": "https://music.yandex.ru", "Authorization": f"OAuth {token}"}
        async with aiohttp.ClientSession() as s:
            try:
                async with s.ws_connect("wss://ynison.music.yandex.ru/redirector.YnisonRedirectService/GetRedirectToYnison", headers=headers, timeout=5) as ws:
                    redirect_data = await asyncio.wait_for(ws.receive(), timeout=5)
                    redirect = json.loads(redirect_data.data)
                
                ws_proto["Ynison-Redirect-Ticket"] = redirect["redirect_ticket"]
                payload = {"update_full_state": {"player_state": {"player_queue": {"current_playable_index": -1,"entity_id": "","entity_type": "VARIOUS","playable_list": [],"options": {"repeat_mode": "NONE"},"entity_context": "BASED_ON_ENTITY_BY_DEFAULT","version": {"device_id": device_id, "version": 1, "timestamp_ms": 0}},"status": {"duration_ms": 0,"paused": True,"playback_speed": 1,"progress_ms": 0,"version": {"device_id": device_id, "version": 1, "timestamp_ms": 0}}},"device": {"capabilities": {"can_be_player": True, "can_be_remote_controller": False, "volume_granularity": 16},"info": {"device_id": device_id, "type": "WEB", "title": "Chrome Browser", "app_name": "Chrome"},"volume_info": {"volume": 0},"is_shadow": True},"is_currently_active": False},"rid": "1","player_action_timestamp_ms": 0,"activity_interception_type": "DO_NOT_INTERCEPT_BY_DEFAULT"}
                headers_with_ticket = {"Sec-WebSocket-Protocol": f"Bearer, v2, {json.dumps(ws_proto)}", "Origin": "https://music.yandex.ru", "Authorization": f"OAuth {token}"}
                
                async with s.ws_connect(f"wss://{redirect['host']}/ynison_state.YnisonStateService/PutYnisonState", headers=headers_with_ticket, timeout=5) as ws:
                    await ws.send_str(json.dumps(payload))
                    response_data = await asyncio.wait_for(ws.receive(), timeout=5)
                    return json.loads(response_data.data)
            except (asyncio.TimeoutError, aiohttp.ClientError) as e:
                logger.warning(f"Ynison request failed: {e}")
                raise
